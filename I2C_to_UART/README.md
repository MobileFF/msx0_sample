## DFPlayer MiniをMSX0から制御したい
  
最近、DFPlayer MiniというMP3再生用のモジュールがあるのを知り、年末年始でいじってました。
このモジュール、何が良いかというと、操作コマンドをUARTで行えるので、制御のハードルが比較的低いことがあります。

これを、ポケコンとかMSX0とかのデバイスから制御できないか・・・？ということで、本記事はMSX0での接続についてです。

## 接続の仕組み
  
御存知の通り？MSX0は2024年1月現在、IoT BASIC/BIOSではUARTをサポートしていません。
外部との通信はWiFiかI2Cになります。
  
シリアルコンソールもあるといえばあるのですが、こちらはMSX0をリモートで操作するための仕組みなので、MSX0へのインプットとして使う手はあるものの、MSX0から外部へのデータ送信に使うには中の人にはちょっとハードルが高めではあります。
  
もちろん、WiFiという手もあるのですが、今回はとりあえずMSX0らしく？ということで、I2Cで送ったデータをUARTに流してもらうところを実装してみました。
変換エンジンには、Raspberry　Pi Picoを利用しています。
  
仕掛けはとても単純で、
- まず、MSX0から「データ長（送信データのバイト数）」と「返却を受け取るかどうか(1=受け取る、それ以外=受け取らない)」を`CALL IOTPUT`で２バイト送信。
- その後、「データ本体」をまとめて`CALL IOTPUT`で送信。
- ラズパイpico側はそれらの指示に従い、所定のバイト数を受け取ったら、「データ本体」をUARTに送信。
- 「返却を受け取るかどうか」に1を指定したときは、続けてUARTからレスポンスを受け取り、I2C側に返却する。
- MSX0では`CALL IOTGET`でレスポンスを受信。
  
ざっくりいうと上記のような感じです。

## MSX0側の実装

プログラム全体は、`I2C_UART.BAS`をごらんください。
  
上記の仕掛けに基づき、データ送信サブルーチン（20000〜20999行）では、以下のように`DATA`文から２つのデータを読み込み、`_IOTPUT`で送信しています。
ここでは、`LN=8`および`NR=0`なので、\[8,0\]という2バイトを送信しています。
  
```BASIC
20100 READ LN
20110 READ NR
20200 T1$=CHR$(LN)+CHR$(NR)
20210 _IOTPUT(N$,T1$)
```

その後、さらに`DATA`文から以下のように指定バイト数分（変数`LN`で決定。ここでは8バイト）データを読み込んで変数`T2$`に追加していき、ループ終了後に`_IOTPUT`で`T2$`の内容（8バイト）を送信しています。

ただ一方的にデータを送り続けるだけで良ければ、先頭２バイト（\[8,0\]）は不要で、データそのものをひたすら送るでも大丈夫なのですが、応答を取得できるようにするため、いったん送信がどこで終わるかを知る必要があるため、最初にバイト数を指定しています。

DATA文に記載の８バイトのデータはDFPLayer Miniを想定したものですが、制御コマンドの使用等については、[こちら](https://github.com/DFRobot/DFRobotDFPlayerMini/tree/master/doc)にあるデータシートPDFを参考にしています。
  
## Raspberry Pi pico側の実装
  
Raspberry Pi picoの環境はMicroPythonを想定しています。ファイルは`main.py`と`i2c_slave.py`になります。
I2Cスレーブ動作用のクラス(`i2c_slave.py`)については、
  
[Use Pico as an I2C slave? - Raspberry Pi Forums](https://forums.raspberrypi.com/viewtopic.php?t=302978)
  
に掲載されていたコードを拝借しています。作者の方に深く感謝いたします。

## おことわり
  
本記事で使用しているDFPlayer Miniは正規品ではなく互換品のため、プログラムで想定している挙動が、正規品とは異なっている可能性があります。あしからずご了承ください。
ちなみに中の人が入手した互換品は[Amazonで５個セット1,399円のもの](https://amzn.to/47r4oxP)です。