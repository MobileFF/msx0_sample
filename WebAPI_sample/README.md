# MSX0単体でWebAPIにアクセスして日本語文字列を得るサンプル<!-- omit in toc -->

- [能書き](#能書き)
- [利用準備](#利用準備)
- [DecodeUTF8toSJIS\_forMSXのサンプルプログラムのサブルーチン化](#decodeutf8tosjis_formsxのサンプルプログラムのサブルーチン化)
- [郵便番号APIにアクセスするサンプルプログラム](#郵便番号apiにアクセスするサンプルプログラム)

## 能書き

MSX0単体でWebAPIにアクセスしてUTF8のJSONデータを取得し、特定のプロパティだけを取り出して表示するサンプルコードです。

例として、株式会社アイビスさんが提供している「郵便番号検索API」にアクセスして郵便番号から住所データを取得しています。

郵便番号APIについてはこちらをご覧ください。

[https://zipcloud.ibsnet.co.jp/doc/api](https://zipcloud.ibsnet.co.jp/doc/api)

UTF8文字列をShiftJISコードの文字列に変換するソリューションは、[IKATEN](https://github.com/IKATEN-X)氏の[DecodeUTF8toSJIS_forMSX](https://github.com/IKATEN-X/DecodeUTF8toSJIS_forMSX)を利用させていただきました。また動作サイトのサンプルコードをサブルーチン形式に改変して利用しております。

JSONのパースについては、[ricbit](https://github.com/ricbit)氏の[MSX JSON Parser](https://github.com/ricbit/msxjson)を利用しています。

## 利用準備

DecodeUTF8toSJIS_forMSXのサイトから「UTF8SJIS.txt」をダウンロードし、MSX0のディスクイメージにコピーしておきます。

同様に、MSX JSON Parserのサイトから「json.bin」をダウンロードし、MSX0のディスクイメージにコピーしておきます。

## DecodeUTF8toSJIS_forMSXのサンプルプログラムのサブルーチン化

IKATEN氏のUTF8→SJIS変換のサンプルプログラムは、単体でUTF8エンコードのテキストファイルをディスクから読み取り、SJISに変換して表示してくれるものですが、自作のプログラムに組み込むにあたり、サブルーチン化したかったので、一部改変しました。またファイルディスクリプタはBASICプログラム内で他のファイルを使うことも想定し、UTF8SJIS.txtは余裕を見て大きめの番号(#5)でオープンしています。

使い方としては、文字列変数TX$に変換させたいUTF8文字列を入れておき、GOSUB 60000で変換ルーチンを呼び出します。そうすると文字列変数SJ$にSJIS変換された結果の文字列が入ってきますので、RETURN後はSJ$を煮るなり焼くなりPRINTするなりすればOKです。

サブルーチン部分だけを抜粋したBASICプログラム（U8SJ_SUB.BAS）も置いてありますので参考になりましたら幸いです。

## 郵便番号APIにアクセスするサンプルプログラム

MSX0に添付されていたサンプルプログラム(SEND2NET.BAS)を参考に、HTTP GETでアクセスして得られた結果からJSONドキュメント部分を取り出し、さらにそこから住所データに該当するプロパティを抽出して画面に表示します。

おおよそのプログラムの構成は以下のとおりです。

|行番号 | 内容 |
|------|--------|
|1000〜|初期化処理、json.binのロードと実行|
|2000〜|HTTPアクセス用の情報を設定|
|3000〜|サーバへの接続確認|
|4000〜|郵便番号の入力|
|5000〜|リクエスト内容の作成|
|6000〜|HTTP GETリクエスト送信|
|7000〜|HTTPレスポンス受信 JSON部分をメモリに格納|
|8000〜|MSX JSON Parserでデータ取り出し＋UTF8→SJIS変換し画面に表示|
|9000〜|後処理（ファイルクローズ等）をして終了|
|60000〜|UTF8→SJIS変換のサブルーチン|

ちなみに、MSX JSON Parserは最初からBASICから呼ばれることを想定した設計になっているので、リファレンスに従い素直に利用できました。

パーサーの本体はjson.binという1KB未満のバイナリファイルで、デフォルトではD000Hに配置、実行されてUSR関数をUSR0〜2まで作ります。

受信したJSONはメモリ上の任意の場所に書き込んでおく必要があります。今回は大きさを鑑みて4KB未満だろうと判断しC000Hから配置しています。

あとは受信したJSONをPOKE文でC000H以降に書き込むのですが、CALL IOTGETで受信する内容はHTTPレスポンスを16バイトずつ分割したものなので、どこからJSON（HTTPボディ）がスタートするのかを判別しなければいけません。今回は超手抜きサンプルなのでIOTGETした応答の中に"{"が含まれていたら書き込みをスタートするようにしています。

以上
